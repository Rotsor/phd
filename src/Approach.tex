\chapter{Approach\label{chap:Approach}}

The subject of this thesis is the advancement of compositional techniques for circuit synthesis. We start by discusssing our contribution to the compositional circuit synthesis based on STGs and present the resynthesis technique. Next we introduce the parametrised graphs formalism naturally supporting compositional reasoning. 


\section{Overview}
Handshake circuits~\cite{van2004handshake} are widely applied in the design and synthesis of real-life hardware.
One prominent problem is obtaining an efficient implementation from a \emph{structural} compositional specification.
Syntax-based synthesis tools such as Balsa~\cite{balsa} are unable to take into account the compositional
behaviour of STGs corresponding to handshake circuit components. To address this issue we propose 
a technique that selectively composes STGs of related components to obtain a smaller and more performant
circuit without suffering state space explosion commonly associated with Petri net based techniques~\cite{Valmari}.
This transformation, which we refer to as \emph{resynthesis}~\cite{ukaf_balsa_resynthesis}, is accomplished in three stages. First, we apply a heuristic to identify the most promising candidates for STG-level composition. Second, we perform a parallel composition of the selected component STGs and as a result obtain a new handshake circuit with custom components, functionally equivalent to a combination of elementary components. Finally, a gate-level implementation is obtained from the new handshake circuit via a component-wise synthesis of STGs.

Unfortunately, the standard definition of parallel composition almost always yields a `messy' Petri net, with many implicit places, causing performance deterioration in techniques that are based on structural methods such as the resynthesis approach. To counter this, we propose an improved algorithm for computing the parallel composition. The algorithm generally produces nets with fewer implicit places that are better suited for subsequent application of structural methods~\cite{improved_par_comp}.

In addition to purely structural composition of STGs, it is also beneficial to consider a mixture of 
structural and behavioural composition. Conditional Partial Order Graphs (CPOG)~\cite{2009_mokhov_phd} is a graph-based notation supporting compact
representation and efficient manipulation of both structural and behavioural composition styles. As one example, when developing complex circuit, it is
often necessary to consider several operational modes of a circuit. 
For this, one needs methodologies and tools to exploit similarities between
the individual modes and hence lift the level of discourse to behaviour families.
This necessitates that behaviours are managed in a compositional
way: the specification of the system must be composed from specifications
of its blocks. Furthermore, since the approach is intended to be a part of a safety critical toolchain, it is essential that such a  specification is amenable to mechanised reasoning and transformation.

In Chapter~\ref{chap:PGAlgebra} we propose an extension of the CPOG formalism, called Parameterised Graph (PG).
PGs deal with general graphs rather than just partial orders. We introduce an algebra of Parameterised Graphs by specifying the
equivalence relation via a set of axioms, which we prove to be sound,
minimal and complete~\cite{pg_algebra}. This result allows one to manipulate a PG model
as an algebraic expression applying the bi-directional rewrite rules of this algebra. This is  in contrast to the CPOG formalism that does not offer a unifying algebraic structure. We demonstrate
the usefulness of the developed formalism with two case studies coming
from the area of microelectronics design.

The CPOG formalism can be applied to merge several distinct behaviours
into a single compact CPOG~\cite{2009_mokhov_phd}. As one example, this has been previously used to
synthesise control logic for instruction decoding. In this thesis (Chapter~\ref{chap:PGEncoding}) 
we improve upon this work by offering a powerful technique to automatically discover an optimal encoding and
synthesise a matching optimal decoding circuit. From the outset, we consider a larger set of potential solutions
which enables us to formulate the global optimality criterion. We use an automated satisfiability solving 
techniques to find an optimal solution~\cite{cpog_encoding}.


\section{Balsa Resynthesis\label{sec:Balsa-Introduction}}

The main obstacle for the wider acceptance of asynchronous systems is the inherent complexity of their design. Several solutions are
accepted by the industry to help to simplify the design process through abstraction
of predesigned asynchronous circuit parts as standardised high level
components. A designer is able to use these components as ``building
blocks'', and then obtain the final gate-level design through an
automated mapping process. Some of the well-known asynchronous
design automation packages, such as Tangram~\cite{951597}, and Balsa~\cite{balsa},
define a high-level programming language that is used to describe
systems. The language constructs are then directly translated into
a network of \emph{handshake components}-- blocks with predefined
functionality that use \emph{handshakes} to interface with other components,
which are in turn mapped into a gate netlist~~\cite{van2004handshake}.

Although this method greatly enhances the designer's productivity,
it has several important drawbacks. Of these, the control-path overhead
is the most decisive. The controllers obtained by syntax-directed
mapping are usually far from optimal because the predesigned components
are required to implement their declared protocols fully and correctly
in order to be reusable in all possible circuit configurations. However,
it is often the case that a significant part of their functionality
becomes redundant due to the peculiarities of the specific configuration,
e.g. in many cases full handshaking between the components can be
avoided.

This redundancy may be eliminated by replacing a manually designed
gate-level implementation of the high level components with an equivalent
STG~(signal transition graph) specification~\cite{Yakovlev_1998_cs}.
The STGs of individual components are then composed together to form a
 STG representation of the whole system STG~\cite{785214} and is optimised with \noun{petrify~}\cite{cortadella_petrify}.
An optimal gate-level implementation is then automatically produced
from the STG using tools such as \noun{petrify}~\cite{cortadella_petrify},
\noun{SIS}~\cite{Sentovich:M92/41} and \noun{MPSat}~\cite{Khomenko_2004_MPSAT}.
Automatic synthesis becomes problematic when the size of a STG becomes
large: modern synthesis tools can handle STGs of no more than 100
signals. The impact of this problem can be lessened by including STG decomposition tools~\cite{DesiJ} into the workflow. They break a large, optimised STG down into several smaller STGs that are synthesisable
in reasonable time. Alternatively, the decomposition step is carried
out at the level of handshake circuits, dividing a circuit into several
smaller blocks of components.

\input{introduction/par_comp}
\input{introduction/pg_algebra}
\input{introduction/pg_encoding}
\input{introduction/agda}
