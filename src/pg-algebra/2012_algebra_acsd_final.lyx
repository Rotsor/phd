#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\pagestyle{plain}
\end_preamble
\options conference
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans helvet
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Algebra of Parameterised Graphs
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
IEEEauthorblockN{Andrey Mokhov
\backslash
IEEEauthorrefmark{2}, Victor Khomenko
\backslash
IEEEauthorrefmark{2}, Arseniy Alekseyev
\backslash
IEEEauthorrefmark{3}, Alex Yakovlev
\backslash
IEEEauthorrefmark{3}}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
IEEEauthorblockA{
\backslash
IEEEauthorrefmark{2}School of Computing Science, Newcastle University, UK}
\end_layout

\begin_layout Plain Layout


\backslash
IEEEauthorblockA{
\backslash
IEEEauthorrefmark{3}School of Electrical, Electronic and Computer Engineering,
 Newcastle University, UK}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
One of the difficulties in designing modern hardware systems is the necessity
 to comprehend and to deal with a very large number of system configurations,
 operational modes, and behavioural scenarios.
 It is often infeasible to consider and specify each individual mode explicitly,
 and one needs methodologies and tools to exploit similarities between the
 individual modes and work with groups of modes rather than individual ones.
 The modes and groups of modes have to be managed in a compositional way:
 the specification of the system should be composed from specifications
 of its blocks.
 This includes both structural and behavioural composition.
 Furthermore, one should be able to transform and optimise the specifications
 in a fully formal and natural way.
\end_layout

\begin_layout Abstract
In this paper we propose a new formalism, called Parameterised Graphs.
 It extends the existing Conditional Partial Order Graphs (CPOGs) formalism
 in several ways.
 First, it deals with general graphs rather than just partial orders.
 Moreover, it is fully compositional.
 To achieve this we introduce an algebra of Parameterised Graphs by specifying
 the equivalence relation by a set of axioms, which is proved to be sound,
 minimal and complete.
 This allows one to manipulate the specifications as algebraic expressions
 using the rules of this algebra.
 We demonstrate the usefulness of the developed formalism on two case studies
 coming from the area of microelectronics design.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset

While the complexity of modern hardware exponentially increases due to Moore's
 law, the time-to-market is reducing.
 The number of available transistors on chip exceeds the capabilities of
 designers to meaningfully use them: this 
\emph on
design productivity gap
\emph default
 is a major challenge in the microelectronics industry
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2009_design_itrs"

\end_inset

.
 One of the difficulties of the design is the necessity to comprehend and
 to deal with a very large number of system configurations, operational
 modes, and behavioural scenarios.
 The contemporary systems often have abundant functionality and enjoy features
 like fault-tolerance, dynamic reconfigurability, power management, all
 of which greatly increase the number of possible modes of operation.
 Hence, it is often infeasible to consider and specify each individual mode
 explicitly, and one needs methodologies and tools to exploit similarities
 between the individual modes and work with groups of modes rather than
 individual ones.
 The modes and groups of modes have to be managed in a compositional way:
 the specification of the system should be composed from specifications
 of its blocks.
 This includes both structural and behavioural composition.
 Furthermore, one should be able to transform and optimise the specifications
 in a fully formal and natural way.
\end_layout

\begin_layout Standard
In this paper we continue the work started in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2010_mokhov_ieee"

\end_inset

, where a formal model, called Conditional Partial Order Graphs (CPOGs),
 was introduced.
 It allowed to represent individual system configurations and operational
 modes as annotated graphs, and to overlay them exploiting their similarities.
 However, the formalism lacked the compositionality and the ability to compare
 and transform the specifications in a formal way.
 In particular, CPOGs always represented the specification as a 
\begin_inset Quotes els
\end_inset

flat
\begin_inset Quotes ers
\end_inset

 structure (similar to the canonical form defined in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Parametrised-Graphs"

\end_inset

), hence a hierarchical representation of a system as a composition of its
 components was not possible.
 We extend this formalism in several ways:
\end_layout

\begin_layout Itemize
We move from the graphs representing partial orders to general graphs.
 Nevertheless, if partial orders are the most natural way to represent a
 certain aspect of system, this still can be handled.
\end_layout

\begin_layout Itemize
The new formalism is fully compositional.
\end_layout

\begin_layout Itemize
We describe the equivalence relation between the specifications as a set
 of axioms, obtaining an algebra.
 This set of axioms is proved to be sound, minimal and complete.
\end_layout

\begin_layout Itemize
The developed formalism allows to manipulate the specifications as algebraic
 expressions using the rules of the algebra.
 In a sense this can be viewed as adding a syntactic level to the semantic
 representation of specifications, and is akin to the relationship between
 digital circuits and Boolean algebra.
\end_layout

\begin_layout Standard
We demonstrate the usefulness of the developed formalism on two case studies.
 The first one is concerned with development of a phase encoding controller,
 which represents information by the order of arrival of signals on 
\begin_inset Formula $n$
\end_inset

 wires.
 As there are 
\begin_inset Formula $n!$
\end_inset

 possible arrival orders, there is a challenge to specify the set of correspondi
ng behavioural scenarios in a compact way.
 The proposed formalism not only allows to solve this problem, but also
 does it in a compositional way, by obtaining the final specification as
 a composition of fixed-size fragments describing the behaviours of pairs
 of wires (the latter was impossible with CPOGs).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_3.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{1}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_4.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_overlay_3_4.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{1}+G_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_sequence_3_4.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{1}\rightarrow G_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overlay and sequence example (no common vertices)
\begin_inset CommandInset label
LatexCommand label
name "fig:Overlay-and-sequence-no-common"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_1.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{1}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_2.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_overlay_1_2.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{1}+G_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/graph_sequence_1_2.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Graph 
\begin_inset Formula $G_{1}\rightarrow G_{2}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Overlay and sequence example (common vertices)
\begin_inset CommandInset label
LatexCommand label
name "fig:Overlay-and-sequence"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second case study is concerned with designing a microcontroller for
 a simple processor.
 The processor can execute several classes of instructions, and each class
 is characterised by a specific execution scenario of the operational units
 of the processor.
 In turn, the scenarios of conditional instructions have to be composed
 of sub-scenarios corresponding to the current value of the appropriate
 ALU flag.
 The overall specification of the microcontroller is then obtained algebraically
, by composing scenarios of each class of instructions.
\end_layout

\begin_layout Standard
The full version of this paper can be found in the technical report
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2011_mokhov_pg"

\end_inset

 (available on-line), where also the missing proofs can be found.
\end_layout

\begin_layout Section
Parameterised Graphs
\begin_inset CommandInset label
LatexCommand label
name "sec:Parametrised-Graphs"

\end_inset


\end_layout

\begin_layout Standard
A 
\emph on
Parameterised Graph
\emph default
 (PG) is a model which has evolved from Conditional Partial Order Graphs
 (CPOG)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2010_mokhov_ieee"

\end_inset

.
 We consider directed graphs 
\begin_inset Formula $G=(V,E)$
\end_inset

 whose vertices are picked from the fixed alphabet of 
\emph on
actions
\emph default
 
\begin_inset Formula $\mathcal{A}=\{a,b,...\}$
\end_inset

.
 Hence the vertices of 
\begin_inset Formula $G$
\end_inset

 would usually model actions
\emph on
 
\emph default
(or 
\emph on
events
\emph default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
/
\end_layout

\end_inset

) of the system being designed, while the arcs would usually model the 
\emph on
precedence
\emph default
 or 
\emph on
causality
\emph default
 relation: if there is an arc going from
\begin_inset space ~
\end_inset


\begin_inset Formula $a$
\end_inset

 to
\begin_inset space ~
\end_inset


\begin_inset Formula $b$
\end_inset

 then action
\begin_inset space ~
\end_inset


\begin_inset Formula $a$
\end_inset

 precedes action
\begin_inset space ~
\end_inset


\begin_inset Formula $b$
\end_inset

.
 We will denote the 
\emph on
empty graph
\emph default
 
\begin_inset Formula $(\emptyset,\emptyset)$
\end_inset

 by 
\begin_inset Formula $\varepsilon$
\end_inset

 and the 
\emph on
singleton graphs
\emph default
 
\begin_inset Formula $(\{a\},\emptyset)$
\end_inset

 simply by 
\begin_inset Formula $a$
\end_inset

, for any 
\begin_inset Formula $a\in\mathcal{A}$
\end_inset


\emph on
.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $G_{1}=(V_{1},E_{1})$
\end_inset

 and 
\begin_inset Formula $G_{2}=(V_{2},E_{2})$
\end_inset

 be two graphs, where 
\begin_inset Formula $V_{1}$
\end_inset

 and 
\begin_inset Formula $V_{2}$
\end_inset

 as well as 
\begin_inset Formula $E_{1}$
\end_inset

 and 
\begin_inset Formula $E_{2}$
\end_inset

 are not necessarily disjoint.
 We define the following operations on graphs (in the order of increasing
 precedence):
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 6mm
\end_inset

Overlay: 
\begin_inset Formula $G_{1}+G_{2}\overset{\mathrm{df}}{=}(V_{1}\cup V_{2},E_{1}\cup E_{2})$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 6mm
\end_inset

Sequence: 
\begin_inset Formula $G_{1}\rightarrow G_{2}\overset{\mathrm{df}}{=}(V_{1}\cup V_{2},E_{1}\cup E_{2}\cup V_{1}\times V_{2})$
\end_inset

.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 6mm
\end_inset

Condition: 
\begin_inset Formula $[1]G\overset{\mathrm{df}}{=}G$
\end_inset

 and 
\begin_inset Formula $[0]G\overset{\mathrm{df}}{=}\varepsilon$
\end_inset

.
\end_layout

\begin_layout Standard
In other words, the 
\emph on
overlay
\begin_inset space ~
\end_inset


\emph default

\begin_inset Formula $+$
\end_inset

 and 
\emph on
sequence
\emph default

\begin_inset space ~
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset

 are binary operations on graphs with the following semantics: 
\begin_inset Formula $G_{1}+G_{2}$
\end_inset

 is a graph obtained by 
\emph on
overlaying
\emph default
 graphs
\begin_inset space ~
\end_inset


\begin_inset Formula $G_{1}$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $G_{2}$
\end_inset

, i.e.
 it contains the union of their vertices and arcs, while graph 
\begin_inset Formula $G_{1}\rightarrow G_{2}$
\end_inset

 contains the union plus the arcs connecting every vertex from graph
\begin_inset space ~
\end_inset


\begin_inset Formula $G_{1}$
\end_inset

 to every vertex from graph
\begin_inset space ~
\end_inset


\begin_inset Formula $G_{2}$
\end_inset

 (self-loops can be formed in this way if 
\begin_inset Formula $V_{1}$
\end_inset

 and 
\begin_inset Formula $V_{2}$
\end_inset

 are not disjoint).
 From the behavioural point of view, if graphs
\begin_inset space ~
\end_inset


\begin_inset Formula $G_{1}$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $G_{2}$
\end_inset

 correspond to two systems then 
\begin_inset Formula $G_{1}+G_{2}$
\end_inset

 corresponds to their 
\emph on
parallel composition
\emph default
 and 
\begin_inset Formula $G_{1}\rightarrow G_{2}$
\end_inset

 corresponds to their 
\emph on
sequential composition
\emph default
.
 One can observe that any non-empty graph can be obtained by successively
 applying the operations 
\begin_inset Formula $+$
\end_inset

 and 
\begin_inset Formula $\rightarrow$
\end_inset

 to the singleton graphs.
\end_layout

\begin_layout Standard
Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overlay-and-sequence-no-common"

\end_inset

 shows an example of two graphs together with their overlay and sequence.
 One can see that the overlay does not introduce any dependencies between
 the actions coming from different graphs, therefore they can be executed
 concurrently.
 On the other hand, the sequence operation imposes the order on the actions
 by introducing new dependencies between actions 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $c$
\end_inset

 coming from graph 
\begin_inset Formula $G_{1}$
\end_inset

 and action 
\begin_inset Formula $d$
\end_inset

 coming from graph 
\begin_inset Formula $G_{2}$
\end_inset

.
 Hence, the resulting system behaviour is interpreted as the behaviour specified
 by graph 
\begin_inset Formula $G_{1}$
\end_inset

 followed by the behaviour specified by graph 
\begin_inset Formula $G_{2}$
\end_inset

.
 Another example of system composition is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overlay-and-sequence"

\end_inset

.
 Since the graphs have common vertices, their compositions are more complicated,
 in particular, their sequence contains the self-dependencies 
\begin_inset Formula $(b,b)$
\end_inset

 and 
\begin_inset Formula $(d,d)$
\end_inset

 which lead to a 
\emph on
deadlock
\emph default
 in the resulting system: action 
\begin_inset Formula $a$
\end_inset

 can occur, but all the remaining actions are locked.
\end_layout

\begin_layout Standard
Given a graph
\begin_inset space ~
\end_inset


\begin_inset Formula $G$
\end_inset

, the unary 
\emph on
condition
\emph default
 operations can either preserve it (
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
/
\end_layout

\end_inset


\emph on
true condition
\emph default
 
\begin_inset Formula $[1]G$
\end_inset

) or nullify it (
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
/
\end_layout

\end_inset


\emph on
false condition
\emph default
 
\begin_inset Formula $[0]G$
\end_inset

).
 They should be considered as a family 
\begin_inset Formula $\{[b]\}_{b\in\mathbb{B}}$
\end_inset

 of operations parameterised by a Boolean value
\begin_inset space ~
\end_inset


\begin_inset Formula $b$
\end_inset

.
\end_layout

\begin_layout Standard
Having defined the basic operations on the graphs, one can build graph expressio
ns using these operations, the empty graph 
\begin_inset Formula $\varepsilon$
\end_inset

, the singleton graphs 
\begin_inset Formula $a\in\mathcal{A}$
\end_inset

, and the Boolean constants 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 (as the parameters of the conditional operations) --- much like the usual
 arithmetical expressions.
 We now consider replacing the Boolean constants with Boolean variables
 or general predicates (this step is akin going from arithmetic to algebraic
 expressions).
 The value of such an expression depends on the values of its parameters,
 and so we call such an expression a 
\emph on
parameterised graph
\emph default

\begin_inset space ~
\end_inset

(PG).
\end_layout

\begin_layout Standard
One can easily prove the following properties of the operations introduced
 above.
\end_layout

\begin_layout Itemize
\begin_inset space \hspace{}
\length -1mm
\end_inset

Properties of overlay:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Identity: 
\begin_inset Formula $G+\varepsilon=G$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Commutativity: 
\begin_inset Formula $G_{1}+G_{2}=G_{2}+G_{1}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Associativity: 
\begin_inset Formula $(G_{1}+G_{2})+G_{3}=G_{1}+(G_{2}+G_{3})$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset space \hspace{}
\length -1mm
\end_inset

Properties of sequence:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Left
\begin_inset space ~
\end_inset

identity: 
\begin_inset Formula $\varepsilon\rightarrow G=G$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Right
\begin_inset space ~
\end_inset

identity: 
\begin_inset Formula $G\rightarrow\varepsilon=G$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Associativity: 
\begin_inset Formula $(G_{1}\!\rightarrow\! G_{2})\!\rightarrow\! G_{3}=G_{1}\!\rightarrow\!(G_{2}\!\rightarrow\! G_{3})$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset space \hspace{}
\length -1mm
\end_inset

Other properties:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space \hspace{}
\length 2mm
\end_inset

Left/right
\begin_inset space ~
\end_inset

distributivity: 
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
\begin{array}{c}
G_{1}\rightarrow(G_{2}+G_{3})=G_{1}\rightarrow G_{2}+G_{1}\rightarrow G_{3}\\
(G_{1}+G_{2})\rightarrow G_{3}=G_{1}\rightarrow G_{3}+G_{2}\rightarrow G_{3}
\end{array}
\]

\end_inset


\begin_inset VSpace -1em
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \hspace{}
\length 2mm
\end_inset

Decomposition: 
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
G_{1}\!\rightarrow\! G_{2}\!\rightarrow\! G_{3}\!=\! G_{1}\!\rightarrow\! G_{2}+G_{1}\!\rightarrow\! G_{3}+G_{2}\!\rightarrow\! G_{3}
\]

\end_inset


\begin_inset VSpace -1.3em
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset space \hspace{}
\length -1mm
\end_inset

Properties involving conditions:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Conditional
\begin_inset space ~
\end_inset


\begin_inset Formula $\varepsilon$
\end_inset

: 
\begin_inset Formula $[b]\varepsilon=\varepsilon$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Conditional
\begin_inset space ~
\end_inset

overlay: 
\begin_inset Formula $[b](G_{1}+G_{2})=[b]G_{1}+[b]G_{2}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

Conditional
\begin_inset space ~
\end_inset

sequence: 
\begin_inset space \hspace{}
\length -0.5mm
\end_inset


\begin_inset Formula $[b](G_{1}\!\rightarrow\! G_{2})\!=\![b]G_{1}\!\rightarrow\![b]G_{2}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

AND-condition: 
\begin_inset Formula $[b_{1}\wedge b_{2}]G=[b_{1}][b_{2}]G$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset space \hspace{}
\length 2mm
\end_inset

OR-condition: 
\begin_inset Formula $[b_{1}\vee b_{2}]G=[b_{1}]G+[b_{2}]G$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \hspace{}
\length 2mm
\end_inset

Condition
\begin_inset space ~
\end_inset

regularisation: 
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
[b_{1}]G_{1}\!\rightarrow\![b_{2}]G_{2}\!=\![b_{1}]G_{1}+[b_{2}]G_{2}+[b_{1}\wedge b_{2}](G_{1}\!\rightarrow\! G_{2})
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now, due to the above properties of the operators, it is possible to define
 the following canonical form of a PG.
 In the proof below, we call a singleton graph, possibly prefixed with a
 condition, a 
\emph on
literal
\emph default
.
\end_layout

\begin_layout Proposition
\begin_inset ERT
status open

\begin_layout Plain Layout

[Canonical form of a PG]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:Canonical-form"

\end_inset

 Any PG can be rewritten in the following canonical form:
\begin_inset Formula 
\begin{equation}
\left(\sum_{v\in V}[b_{v}]v\right)+\left(\sum_{u,v\in V}[b_{uv}](u\rightarrow v)\right),\label{eq:canonical-form}
\end{equation}

\end_inset


\end_layout

\begin_layout Proposition
where:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $V$
\end_inset

 is a subset of singleton graphs that appear in the original PG;
\end_layout

\begin_layout Itemize
for all 
\begin_inset Formula $v\in V$
\end_inset

, 
\begin_inset Formula $b_{v}$
\end_inset

 are canonical forms of Boolean expressions and are distinct from 0;
\end_layout

\begin_layout Itemize
for all 
\begin_inset Formula $u,v\in V$
\end_inset

, 
\begin_inset Formula $b_{uv}$
\end_inset

 are canonical forms of Boolean expressions such that 
\begin_inset Formula $b_{uv}\Rightarrow b_{u}\wedge b_{v}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
(i) First we prove that any PG can be converted to the form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

).
\begin_inset Note Note
status open

\begin_layout Plain Layout
Example?
\end_layout

\end_inset


\end_layout

\begin_layout Proof
All the occurrences of 
\begin_inset Formula $\varepsilon$
\end_inset

 in the expression can be eliminated by the identity and conditional 
\begin_inset Formula $\varepsilon$
\end_inset

 properties (unless the whole PG equals to 
\begin_inset Formula $\varepsilon$
\end_inset

, in which case we take 
\begin_inset Formula $V=\emptyset$
\end_inset

).
 To avoid unconditional subexpressions, we prefix the resulting expression
 with `
\begin_inset Formula $[1]$
\end_inset

', and then by the conditional overlay/sequence properties we propagate
 all the conditions that appear in the expression down to the singleton
 graphs (compound conditions can be always reduced to a single one by the
 AND-condition property).
 By the decomposition and distributivity properties, the expression can
 be rewritten as an overlay of literals and subexpressions of the form 
\begin_inset Formula $l_{1}\rightarrow l_{2}$
\end_inset

, where 
\begin_inset Formula $l_{1}$
\end_inset

 and 
\begin_inset Formula $l_{2}$
\end_inset

 are literals.
 The latter subexpressions can be rewritten using the condition regularisation
 rule:
\begin_inset Formula 
\[
[b_{1}]u\rightarrow[b_{2}]v=[b_{1}]u+[b_{2}]v+[b_{1}\wedge b_{2}](u\rightarrow v)
\]

\end_inset

Now, literals corresponding to the same singleton graphs, as well as subexpressi
ons of the form 
\begin_inset Formula $[b](u\rightarrow v)$
\end_inset

 that correspond to the same pair of singleton graphs 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

, are combined using the OR-condition property.
 Then the literals prefixed with 0 conditions can be dropped.
 Now the set 
\begin_inset Formula $V$
\end_inset

 consists of all the singleton graphs occurring in the literals.
 To turn the overall expression into the required form it only remains to
 add missing subexpressions of the form 
\begin_inset Formula $[0](u\rightarrow v)$
\end_inset

 for every 
\begin_inset Formula $u,v\in V$
\end_inset

 such that the expression does not contain the subexpression of the form
 
\begin_inset Formula $[b](u\rightarrow v)$
\end_inset

.
 Note that the property 
\begin_inset Formula $b_{uv}\Rightarrow b_{u}\wedge b_{v}$
\end_inset

 is always enforced by this construction:
\end_layout

\begin_deeper
\begin_layout Itemize
condition regularisation ensures this property;
\end_layout

\begin_layout Itemize
combining literals using the OR-condition property can only strengthen the
 right hand side of this implication, and so cannot violate it;
\end_layout

\begin_layout Itemize
adding 
\begin_inset Formula $[0](u\rightarrow v)$
\end_inset

 does not violate the property as it trivially holds when 
\begin_inset Formula $b_{uv}=0$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
(ii) We now show that (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

) is a canonical form, i.e.
 if 
\begin_inset Formula $L=R$
\end_inset

 then their canonical forms 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 coincide.
\end_layout

\begin_layout Proof
For the sake of contradiction, assume this is not the case.
 Then we consider two cases (all possible cases are symmetric to one of
 these two):
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 contains a literal 
\begin_inset Formula $[b_{v}]v$
\end_inset

 whereas 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 either contains a literal 
\begin_inset Formula $[b_{v}']v$
\end_inset

 with 
\begin_inset Formula $b_{v}'\not\equiv b_{v}$
\end_inset

 or does not contain any literal corresponding to 
\begin_inset Formula $v$
\end_inset

, in which case we say that it contains a literal 
\begin_inset Formula $[b_{v}']v$
\end_inset

 with 
\begin_inset Formula $b_{v}'=0$
\end_inset

.
 Then for some values of parameters one of the graphs will contain vertex
 
\begin_inset Formula $v$
\end_inset

 while the other will not.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 have the same set 
\begin_inset Formula $V$
\end_inset

 of vertices, but 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 contains a subexpression 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $[b_{uv}](u\rightarrow v)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 whereas 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 contains a subexpression 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $[b_{uv}'](u\rightarrow v)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 with 
\begin_inset Formula $b_{uv}'\not\equiv b_{uv}$
\end_inset

.
 Then for some values of parameters one of the graphs will contain the arc
 
\begin_inset Formula $(u,v)$
\end_inset

 (note that due to 
\begin_inset Formula $b_{uv}\Rightarrow b_{u}\wedge b_{v}$
\end_inset

 and 
\begin_inset Formula $b_{uv}'\Rightarrow b_{u}\wedge b_{v}$
\end_inset

 vertices 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are present), while the other will not.
\end_layout

\end_deeper
\begin_layout Proof
In both cases there is a contradiction with 
\begin_inset Formula $L=R$
\end_inset

.
\end_layout

\begin_layout Standard
This canonical form allows one to lift the notion of 
\emph on
adjacency matrix
\emph default
 of a graph to PGs.
 Recall that the adjacency matrix 
\begin_inset Formula $(b_{uv})$
\end_inset

 of a graph 
\begin_inset Formula $(V,E)$
\end_inset

 is a 
\begin_inset Formula $|V|\times|V|$
\end_inset

 Boolean matrix such that 
\begin_inset Formula $b_{uv}=1$
\end_inset

 if 
\begin_inset Formula $(u,v)\in E$
\end_inset

 and 
\begin_inset Formula $b_{uv}=0$
\end_inset

 otherwise.
 The adjacency matrix of a PG is obtained from the canonical form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

) by gathering the predicates 
\begin_inset Formula $b_{uv}$
\end_inset

 into a matrix.
 The adjacency matrix of a PG is similar to that of a graph, but it contains
 predicates rather than Boolean values.
 It does not uniquely determine a PG, as the predicates of the vertices
 cannot be derived from it; to fully specify a PG one also has to provide
 predicates 
\begin_inset Formula $b_{v}$
\end_inset

 from the canonical form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

).
 
\end_layout

\begin_layout Standard
Another advantage of this canonical form is that it provides a graphical
 notation for PGs.
 The vertices occurring in the canonical form (set 
\begin_inset Formula $V$
\end_inset

) can be represented by circles, and the subexpressions of the form 
\begin_inset Formula $u\rightarrow v$
\end_inset

 by arcs.
 The label of a vertex 
\begin_inset Formula $v$
\end_inset

 consists of the vertex name, colon and the predicate 
\begin_inset Formula $b_{v}$
\end_inset

, while every arc
\begin_inset space ~
\end_inset


\begin_inset Formula $(u,v)$
\end_inset

 is labelled with the corresponding predicate 
\begin_inset Formula $b_{uv}$
\end_inset

.
 As adjacency matrices of PGs tend to have many constant elements, we use
 a simplified notation in which the arcs with constant
\begin_inset space ~
\end_inset

0 predicates are not drawn, and constant
\begin_inset space ~
\end_inset

1 predicates are dropped; moreover, it is convenient to assume that the
 predicates on arcs are implicitly ANDed with those on incident vertices
 (to enforce the invariant 
\begin_inset Formula $b_{uv}\Rightarrow b_{u}\wedge b_{v}$
\end_inset

), which often allows one to simplify predicates on arcs.
 This can be justified by introducing the ternary operator, called 
\emph on
conditional sequence
\emph default
:
\begin_inset Formula 
\[
u\overset{b}{\longrightarrow}v\overset{\text{df}}{=}[b](u\rightarrow v)+u+v
\]

\end_inset

Intuitively, PG 
\begin_inset Formula $u\overset{b}{\longrightarrow}v$
\end_inset

 consists of two unconditional vertices connected by an arc with the condition
 
\begin_inset Formula $b$
\end_inset

.
 By case analysis on 
\begin_inset Formula $b_{1}$
\end_inset

 and 
\begin_inset Formula $b_{2}$
\end_inset

 one can easily prove the following properties of the conditional sequence
 that allow simplifying the predicates on arcs:
\begin_inset Formula 
\begin{eqnarray*}
[b_{1}]u\xrightarrow{b_{1}\wedge b_{2}}v & = & [b_{1}]u\overset{b_{2}}{\longrightarrow}v\\
u\xrightarrow{b_{1}\wedge b_{2}}[b_{2}]v & = & u\overset{b_{1}}{\longrightarrow}[b_{2}]v
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Specialisations"

\end_inset

(top) shows an example of a PG.
 The predicates depend on a Boolean variable
\begin_inset space ~
\end_inset


\begin_inset Formula $x$
\end_inset

.
 The predicates of vertices
\begin_inset space ~
\end_inset


\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 are constants
\begin_inset space ~
\end_inset


\begin_inset Formula $1$
\end_inset

; such vertices are called 
\emph on
unconditional
\emph default
.
 Vertices
\begin_inset space ~
\end_inset


\begin_inset Formula $c$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $e$
\end_inset

 are 
\emph on
conditional,
\emph default
 and their predicates are 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $\overline{x}$
\end_inset

, respectively.
 Arcs also fall into two classes: 
\emph on
unconditional,
\emph default
 i.e.
 those whose predicate and the predicates of their incident vertices are
 constants
\begin_inset space ~
\end_inset

1, and 
\emph on
conditional
\emph default
 (in this example, all the arcs are conditional).
\end_layout

\begin_layout Standard
A 
\emph on
specialisation 
\begin_inset Formula $H\vert_{p}$
\end_inset

 of a PG 
\begin_inset Formula $H$
\end_inset

 under predicate 
\begin_inset Formula $p$
\end_inset


\emph default
 is a PG, whose predicates are simplified under the assumption that 
\begin_inset Formula $p$
\end_inset

 holds.
 If 
\begin_inset Formula $H$
\end_inset

 specifies the behaviour of the whole system, 
\begin_inset Formula $H\vert_{p}$
\end_inset

 specifies the part of the behaviour that can be realised under condition
 
\begin_inset Formula $p$
\end_inset

.
 An example of a graph and its two specialisations is presented in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Specialisations"

\end_inset

.
 The leftmost specialisation 
\begin_inset Formula $H\vert_{x}$
\end_inset

 is obtained by removing from the graph those vertices and arcs whose predicates
 evaluate to
\begin_inset space ~
\end_inset

0 under condition
\begin_inset space ~
\end_inset


\begin_inset Formula $x$
\end_inset

, and simplifying the other predicates.
 Hence, vertex
\begin_inset space ~
\end_inset


\begin_inset Formula $e$
\end_inset

 and arcs 
\begin_inset Formula $(a,d)$
\end_inset

, 
\begin_inset Formula $(a,e)$
\end_inset

, 
\begin_inset Formula $(b,d)$
\end_inset

 and 
\begin_inset Formula $(b,e)$
\end_inset

 disappear, and all the other vertices and arcs become unconditional.
 The rightmost specialisation 
\begin_inset Formula $H\vert_{\overline{x}}$
\end_inset

 is obtained analogously.
 Each of the obtained specialisations can be regarded as a specification
 of a particular behavioural scenario of the modelled system, e.g.
 as specification of a processor instruction.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fig/cpog_projections_2.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Specialisations"

\end_inset

PG specialisations: 
\begin_inset Formula $H\vert_{x}$
\end_inset

 and 
\begin_inset Formula $H\vert_{\overline{x}}$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Specification and composition of instructions
\end_layout

\begin_layout Standard
Consider a processing unit that has two registers 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, and can perform two different instructions: 
\emph on
addition
\emph default
 and 
\emph on
exchange
\emph default
 of two variables stored in memory.
 The processor contains five datapath components (denoted by 
\begin_inset Formula $a\dots e$
\end_inset

) that can perform the following atomic actions:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
labelenumi}{
\backslash
alph{enumi})}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Load register 
\begin_inset Formula $A$
\end_inset

 from memory;
\end_layout

\begin_layout Enumerate
Load register 
\begin_inset Formula $B$
\end_inset

 from memory;
\end_layout

\begin_layout Enumerate
Compute the sum of the numbers stored in registers
\begin_inset space ~
\end_inset


\begin_inset Formula $A$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $B$
\end_inset

, and store it in 
\begin_inset Formula $A$
\end_inset

;
\end_layout

\begin_layout Enumerate
Save register 
\begin_inset Formula $A$
\end_inset

 into memory;
\end_layout

\begin_layout Enumerate
Save register 
\begin_inset Formula $B$
\end_inset

 into memory.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
labelenumi}{
\backslash
arabic{enumi}.}
\end_layout

\end_inset

Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab-two-operations"

\end_inset

 describes the addition and exchange instructions in terms of usage of these
 atomic actions.
\end_layout

\begin_layout Standard
The addition instruction consists of loading the two operands from memory
 (causally independent actions
\begin_inset space ~
\end_inset


\begin_inset Formula $a$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $b$
\end_inset

), their addition (action
\begin_inset space ~
\end_inset


\begin_inset Formula $c$
\end_inset

), and saving the result (action
\begin_inset space ~
\end_inset


\begin_inset Formula $d$
\end_inset

).
 Let us assume for simplicity that in this example all causally independent
 actions are always performed concurrently, see the corresponding scenario
 
\begin_inset Formula $\mathit{ADD}$
\end_inset

 in the table.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Addition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exchange
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

a) Load 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

a) Load 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

b) Load 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

b) Load 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sequence
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

c) Add 
\begin_inset Formula $B$
\end_inset

 to 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

d) Save 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

d) Save 
\begin_inset Formula $A$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset space ~
\end_inset

e) Save 
\begin_inset Formula $B$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Execution
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/projection_1.svg
	scale 40
	BoundingBox -10bp 90bp 158bp 220bp

\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/projection_2.svg
	scale 40
	BoundingBox -20bp 90bp 157bp 220bp

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
scenario
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
with maximum
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
concurrency
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathit{ADD}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathit{XCHG}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab-two-operations"

\end_inset

Two instructions specified as partial orders
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The operation of exchange consists of loading the operands (causally independent
 actions
\begin_inset space ~
\end_inset


\begin_inset Formula $a$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $b$
\end_inset

), and saving them into swapped memory locations (causally independent actions
 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $e$
\end_inset

), as captured by the 
\begin_inset Formula $\mathit{XCHG}$
\end_inset

 scenario.
 Note that in order to start saving one of the registers it is necessary
 to wait until both of them have been loaded to avoid overwriting one of
 the values.
\end_layout

\begin_layout Standard
One can see that the two scenarios in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab-two-operations"

\end_inset

 appear to be the two specialisations of the PG shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Specialisations"

\end_inset

, thus this PG can be considered as a joint specification of both instructions.
 Two important characteristics of such a specification are that the common
 events 
\begin_inset Formula $\{a,b,d\}$
\end_inset

 are overlaid, and the choice between the two operations is modelled by
 the Boolean predicates associated with the vertices and arcs of the PG.
 As a result, in our model there is no need for a 
\begin_inset Quotes els
\end_inset

nodal point
\begin_inset Quotes ers
\end_inset

 of choice, which tend to appear in alternative specification models: a
 Petri Net (resp.
 Finite State Machine) would have an explicit choice place (resp.
 state), and a specification written in a Hardware Description Language
 would describe the two instructions by two separate branches of a conditional
 statement
\begin_inset space ~
\end_inset


\family typewriter
if
\family default
 or
\begin_inset space ~
\end_inset


\family typewriter
case
\family default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "1994_de_micheli_book"

\end_inset

).
\end_layout

\begin_layout Standard
The PG operations introduced above allow for a natural specification of
 the system as a collection of its behavioural scenarios, which can share
 some common parts.
 For example, in this case the overall system is composed as
\begin_inset Formula 
\begin{equation}
\begin{array}{c}
H=[x]ADD+[\overline{x}]XCHG=\\
=\![x]((a\!+\! b)\!\rightarrow\! c\!+\! c\!\rightarrow\! d)\!+\![\overline{x}]((a\!+\! b)\!\rightarrow\!(d\!+\! e)).
\end{array}\label{eq:H_ADD_XCHG}
\end{equation}

\end_inset

Such specifications can often be simplified using the properties of graph
 operations.
 The next section describes the equivalence relation between the PGs with
 a set of axioms, thus obtaining an algebra.
\end_layout

\begin_layout Section
Algebra of parameterised graphs
\begin_inset CommandInset label
LatexCommand label
name "sec:Algebra-of-parametrised"

\end_inset


\end_layout

\begin_layout Standard
In this section we define the 
\emph on
algebra of parameterised graphs
\emph default
 (PG-algebra).
\end_layout

\begin_layout Standard
PG-algebra is a tuple
\begin_inset space ~
\end_inset


\begin_inset Formula $\left\langle \mathcal{G},+,\rightarrow,[0],[1]\right\rangle $
\end_inset

, where
\begin_inset space ~
\end_inset


\begin_inset Formula $\mathcal{G}$
\end_inset

 is a set of graphs whose vertices are picked from the alphabet
\begin_inset space ~
\end_inset


\begin_inset Formula $\mathcal{A}$
\end_inset

 and the operations parallel those defined for graphs above.
 The equivalence relation is given by the following axioms.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 is commutative and associative
\end_layout

\begin_layout Itemize
\begin_inset Formula $\rightarrow$
\end_inset

 is associative
\end_layout

\begin_layout Itemize
\begin_inset Formula $\varepsilon$
\end_inset

 is a left and right identity of 
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\rightarrow$
\end_inset

 distributes over 
\begin_inset Formula $+$
\end_inset

:
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
\begin{array}{c}
p\rightarrow(q+r)=p\rightarrow q+p\rightarrow r\\
(p+q)\rightarrow r=p\rightarrow r+q\rightarrow r
\end{array}
\]

\end_inset


\end_layout

\begin_layout Itemize
Decomposition: 
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
p\rightarrow q\rightarrow r=p\rightarrow q+p\rightarrow r+q\rightarrow r
\]

\end_inset


\end_layout

\begin_layout Itemize
Condition: 
\begin_inset Formula $[0]p=\varepsilon$
\end_inset

 and 
\begin_inset Formula $[1]p=p$
\end_inset


\end_layout

\begin_layout Standard
The following derived equalities can be proved from PG-algebra axioms
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "Prop. 2, 3"
key "2011_mokhov_pg"

\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\varepsilon$
\end_inset

 is an identity of 
\begin_inset Formula $+$
\end_inset

: 
\begin_inset Formula $p+\varepsilon=p$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 is idempotent: 
\begin_inset Formula $p+p=p$
\end_inset


\end_layout

\begin_layout Itemize
Left and right absorption:
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
\begin{array}{c}
p+p\rightarrow q=p\rightarrow q\\
q+p\rightarrow q=p\rightarrow q
\end{array}
\]

\end_inset


\end_layout

\begin_layout Itemize
Conditional 
\begin_inset Formula $\varepsilon$
\end_inset

: 
\begin_inset Formula $[b]\varepsilon=\varepsilon$
\end_inset


\end_layout

\begin_layout Itemize
Conditional overlay: 
\begin_inset Formula $[b](p+q)=[b]p+[b]q$
\end_inset


\end_layout

\begin_layout Itemize
Conditional sequence: 
\begin_inset Formula $[b](p\rightarrow q)=[b]p\rightarrow[b]q$
\end_inset


\end_layout

\begin_layout Itemize
AND-condition: 
\begin_inset Formula $[b_{1}\wedge b_{2}]p=[b_{1}][b_{2}]p$
\end_inset


\end_layout

\begin_layout Itemize
OR-condition: 
\begin_inset Formula $[b_{1}\vee b_{2}]p=[b_{1}]p+[b_{2}]p$
\end_inset


\end_layout

\begin_layout Itemize
Choice propagation:
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
\begin{array}{c}
[b](p\rightarrow q)+[\overline{b}](p\rightarrow r)=p\rightarrow([b]q+[\overline{b}]r)\\
{}[b](p\rightarrow r)+[\overline{b}](q\rightarrow r)=([b]p+[\overline{b}]q)\rightarrow r
\end{array}
\]

\end_inset


\end_layout

\begin_layout Itemize
Condition regularisation:
\begin_inset VSpace -0.3em
\end_inset


\begin_inset Formula 
\[
[b_{1}]p\rightarrow[b_{2}]q=[b_{1}]p+[b_{2}]q+[b_{1}\wedge b_{2}](p\rightarrow q)
\]

\end_inset


\end_layout

\begin_layout Standard
Note that as 
\begin_inset Formula $\varepsilon$
\end_inset

 is a left and right identity of 
\begin_inset Formula $\rightarrow$
\end_inset

 and 
\begin_inset Formula $+$
\end_inset

, there can be no other identities for these operations.
 Interestingly, unlike many other algebras, the two main operations in the
 PG-algebra have the same identity.
\end_layout

\begin_layout Standard
It is easy to see that PGs are a model of PG-algebra, as all the axioms
 of PG-algebra are satisfied by PGs; in particular, this means that PG-algebra
 is 
\emph on
sound
\emph default
.
 Moreover, any PG-algebra expression has the canonical form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

), as the proof of Prop.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "prop:Canonical-form"

\end_inset

 can be directly imported: 
\end_layout

\begin_layout Itemize
It is always possible to translate a PG-algebra expression to this canonical
 form, as part
\begin_inset space ~
\end_inset

(i) of the proof relies only on the properties of PGs that correspond to
 either PG-algebra axioms or equalities above.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $L=R$
\end_inset

 holds in PG-algebra then 
\begin_inset Formula $L=R$
\end_inset

 holds also for PGs (as PGs are a model of PG-algebra), and so the PGs 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 coincide, see part
\begin_inset space ~
\end_inset

(ii) of the proof.
 Since PGs 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 are in fact the same objects as the expressions 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 of the PG-algebra, (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

) is a canonical form of a PG-algebra expression.
\end_layout

\begin_layout Standard
This also means that PG-algebra is 
\emph on
complete
\emph default
 w.r.t.
 PGs, i.e.
 any PG equality can be either proved or disproved using the axioms of PG-algebr
a (by converting to the canonical form).
 
\end_layout

\begin_layout Standard
The provided set of axioms of PG-algebra is 
\emph on
minimal
\emph default
, i.e.
 no axiom from this set can be derived from the others.
 The minimality was checked by enumerating the fixed-size models of PG-algebra
 with the help of the 
\noun on
Alg
\noun default
 tool
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2011_bizjak_alg"

\end_inset

: It turns out that removing any of the axioms leads to a different number
 of non-isomorphic models of a particular size, implying that all the axioms
 are necessary.
\end_layout

\begin_layout Standard
Hence, the following result holds:
\end_layout

\begin_layout Theorem
\begin_inset ERT
status open

\begin_layout Plain Layout

[Soundness, Minimality and Completeness]
\end_layout

\end_inset

 The set of axioms of PG-algebra is sound, minimal and complete w.r.t.
 PGs.
\end_layout

\begin_layout Remark*
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
[x]((a+b)\rightarrow c+c\rightarrow d)+[\overline{x}]((a+b)\rightarrow(d+e)) & = & (\textrm{closure)}\\
{}[x]((a+b)\rightarrow c+(a+b)\rightarrow d+c\rightarrow d)+[\overline{x}]((a+b)\rightarrow(d+e)) & = & (\textrm{decomposition)}\\
{}[x]((a+b)\rightarrow c\rightarrow d)+[\overline{x}]((a+b)\rightarrow(d+e)) & = & (\textrm{choice propagation)}\\
(a+b)\rightarrow([x](c\rightarrow d)+[\overline{x}](d+e)) & = & (\textrm{conditional overlay)}\\
(a+b)\rightarrow([x](c\rightarrow d)+[\overline{x}]d+[\overline{x}]e) & = & (\rightarrow-\textrm{identity)}\\
(a+b)\rightarrow([x](c\rightarrow d)+[\overline{x}](\varepsilon\rightarrow d)+[\overline{x}]e) & = & (\textrm{choice propagation)}\\
(a+b)\rightarrow(([x]c+[\overline{x}]\varepsilon)\rightarrow d+[\overline{x}]e) & = & (\textrm{conditional \varepsilon, +-\textrm{identity)}}\\
(a+b)\rightarrow([x]c\rightarrow d+[\overline{x}]e).
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Simplifying expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:H_ADD_XCHG"

\end_inset

) using the Closure axiom
\begin_inset CommandInset label
LatexCommand label
name "fig:Simplifying-TPG-expressions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Transitive parameterised graphs and their algebra
\end_layout

\begin_layout Standard
In many cases the arcs of the graphs are interpreted as the causality relation,
 and so the graph itself is a partial order.
 However, in practice it is convenient to drop some or all of the transitive
 arcs, i.e.
 two graphs should be considered equal whenever their transitive closures
 are equal.
 E.g.
 in this case the graphs specified by the expressions 
\begin_inset Formula $a\rightarrow b+b\rightarrow c$
\end_inset

 and 
\begin_inset Formula $a\rightarrow b+a\rightarrow c+b\rightarrow c$
\end_inset

 are considered as equal.
 PGs with this equality relation are called 
\emph on
Transitive Parameterised Graphs
\emph default
 (TPG).
 To capture this algebraically, we augment the PG-algebra with the 
\emph on
Closure
\emph default
 axiom:
\begin_inset Formula 
\[
\mbox{{if\ }}q\neq\varepsilon\mbox{{\ then\ }}p\!\rightarrow\! q+q\!\rightarrow\! r=p\!\rightarrow\! q+p\!\rightarrow\! r+q\!\rightarrow\! r.
\]

\end_inset

One can see that by repeated application of this axiom one can obtain the
 transitive closure of any graph, including those with cycles.
 The resulting algebra is called Transitive Parameterised Graphs Algebra
 (TPG-algebra).
\end_layout

\begin_layout Remark*
Note that the condition 
\begin_inset Formula $q\ne\varepsilon$
\end_inset

 in the Closure axiom is necessary, as otherwise
\begin_inset Formula 
\[
a+b=a\!\rightarrow\!\varepsilon+\varepsilon\!\rightarrow\! b=a\!\rightarrow\!\varepsilon+a\!\rightarrow\! b+\varepsilon\!\rightarrow\! b=a\!\rightarrow\! b,
\]

\end_inset

and the operations 
\begin_inset Formula $+$
\end_inset

 and 
\begin_inset Formula $\rightarrow$
\end_inset

 become identical, which is clearly undesirable.
\end_layout

\begin_layout Standard
The Closure axiom helps to simplify specifications by reducing the number
 of arcs and/or simplifying their conditions.
 For example, consider the PG expression
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:H_ADD_XCHG"

\end_inset

).
 As the scenarios of this PG are interpreted as the orders of execution
 of actions, it is natural to use the Closure axiom.
 Note that the expression cannot be simplified in PG-algebra; however, in
 the TPG-algebra it can be considerably simplified, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simplifying-TPG-expressions"

\end_inset

.
\end_layout

\begin_layout Standard
The corresponding TPG is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-simplified-CG-from"

\end_inset

.
 Note that it has fewer conditional elements than the PG in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Specialisations"

\end_inset

; though the specialisations are now different, they have the same transitive
 closures.
\end_layout

\begin_layout Standard
We now lift the canonical form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

) to TPGs and TPG-algebra.
 Note that the only difference is the last requirement.
\end_layout

\begin_layout Proposition
\begin_inset ERT
status open

\begin_layout Plain Layout

[Canonical form of a TPG]
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "prop:Canonical-form-tpg"

\end_inset

 Any TPG can be rewritten in the following canonical form:
\begin_inset Formula 
\begin{equation}
\left(\sum_{v\in V}[b_{v}]v\right)+\left(\sum_{u,v\in V}[b_{uv}](u\rightarrow v)\right),\label{eq:canonical-form-tpg}
\end{equation}

\end_inset

 where:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $V$
\end_inset

 is a subset of singleton graphs that appear in the original TPG;
\end_layout

\begin_layout Enumerate
for all 
\begin_inset Formula $v\in V$
\end_inset

, 
\begin_inset Formula $b_{v}$
\end_inset

 are canonical forms of Boolean expressions and are distinct from 0;
\end_layout

\begin_layout Enumerate
for all 
\begin_inset Formula $u,v\in V$
\end_inset

, 
\begin_inset Formula $b_{uv}$
\end_inset

 are canonical forms of Boolean expressions such that 
\begin_inset Formula $b_{uv}\Rightarrow b_{u}\wedge b_{v}$
\end_inset

;
\end_layout

\begin_layout Enumerate
for all 
\begin_inset Formula $u,v,w\in V$
\end_inset

, 
\begin_inset Formula $b_{uv}\wedge b_{vw}\Rightarrow b_{uw}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
(i) First we prove that any TPG can be converted to the form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form-tpg"

\end_inset

).
\end_layout

\begin_layout Proof
We can convert the expression into the canonical form (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

), which satisfies the requirements 1--3.
 Then we iteratively apply the following transformation, while possible:
 If for some 
\begin_inset Formula $u,v,w\in V$
\end_inset

, 
\begin_inset Formula $b_{uv}\wedge b_{vw}\Rightarrow b_{uw}$
\end_inset

 does not hold (i.e.
 requirement 4 is violated), we replace the subexpression 
\begin_inset Formula $[b_{uw}](u\rightarrow w)$
\end_inset

 with 
\begin_inset Formula $[b_{uw}^{\mathit{new}}](u\rightarrow w)$
\end_inset

 where 
\begin_inset Formula $b_{uw}^{\mathit{new}}\overset{\text{df}}{=}b_{uw}\vee(b_{uv}\wedge b_{vw})$
\end_inset

.
 Observe that after this the requirement 4 will hold for 
\begin_inset Formula $u$
\end_inset

, 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

, and the requirement 3 remains satisfied, i.e.
 
\begin_inset Formula $b_{uw}^{\mathit{new}}\Rightarrow b_{u}\wedge b_{w}$
\end_inset

 due to 
\begin_inset Formula $b_{uv}\Rightarrow b_{u}\wedge b_{v}$
\end_inset

, 
\begin_inset Formula $b_{vw}\Rightarrow b_{v}\wedge b_{w}$
\end_inset

 and 
\begin_inset Formula $b_{uw}\Rightarrow b_{u}\wedge b_{w}$
\end_inset

.
 Moreover, the resulting expression will be equivalent to the one before
 this transformation due to the following equality (see
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2011_mokhov_pg"

\end_inset

 for the proof):
\begin_inset Formula 
\[
\begin{array}{c}
\mbox{{If\ }}v\neq\varepsilon\mbox{{\ then\ }}[b_{uv}](u\rightarrow v)+[b_{vw}](v\rightarrow w)=\\
=[b_{uv}](u\rightarrow v)+[b_{vw}](v\rightarrow w)+[b_{uv}\wedge b_{vw}](u\rightarrow w).
\end{array}
\]

\end_inset


\end_layout

\begin_layout Proof
This iterative process converges, as there can be only finitely many expressions
 of the form (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form-tpg"

\end_inset

) (recall that we assume that the predicates within the conditional operators
 are always in some canonical form), and each iteration replaces some predicate
 
\begin_inset Formula $b_{uw}$
\end_inset

 with a greater one 
\begin_inset Formula $b_{uw}^{\mathit{new}}$
\end_inset

, in the sense that 
\begin_inset Formula $b_{uv}$
\end_inset

 strictly subsumes 
\begin_inset Formula $b_{uw}^{\mathit{new}}$
\end_inset

 (i.e.
 
\begin_inset Formula $b_{uw}\Rightarrow b_{uw}^{\mathit{new}}$
\end_inset

 and 
\begin_inset Formula $b_{uw}\not\equiv b_{uw}^{\mathit{new}}$
\end_inset

 always hold), i.e.
 no predicate can be repeated during these iterations.
\end_layout

\begin_layout Proof
(ii) We now show that (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form-tpg"

\end_inset

) is a canonical form, i.e.
 if 
\begin_inset Formula $L=R$
\end_inset

 then their canonical forms 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 coincide.
\end_layout

\begin_layout Proof
For the sake of contradiction, assume this is not the case.
 Then we consider two cases (all possible cases are symmetric to one of
 these two).
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 contains a literal 
\begin_inset Formula $[b_{v}]v$
\end_inset

 whereas 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 either contains a literal 
\begin_inset Formula $[b_{v}']v$
\end_inset

 with 
\begin_inset Formula $b_{v}'\neq b_{v}$
\end_inset

 or does not contain any literal corresponding to 
\begin_inset Formula $v$
\end_inset

, in which case we say that it contains a literal 
\begin_inset Formula $[b_{v}']v$
\end_inset

 with 
\begin_inset Formula $b_{v}'=0$
\end_inset

.
 Then for some values of parameters one of the graphs will contain vertex
 
\begin_inset Formula $v$
\end_inset

 while the other will not.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 have the same set 
\begin_inset Formula $V$
\end_inset

 of vertices, but 
\begin_inset Formula $\mathit{can}(L)$
\end_inset

 contains a subexpression 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $[b_{uv}](u\!\rightarrow\! v)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 and 
\begin_inset Formula $\mathit{can}(R)$
\end_inset

 contains a subexpression 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $[b_{uv}'](u\!\rightarrow\! v)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 with 
\begin_inset Formula $b_{uv}'\not\equiv b_{uv}$
\end_inset

.
 Then for some values of parameters one of the graphs will contain the arc
 
\begin_inset Formula $(u,v)$
\end_inset

 while the other will not.
 Since the transitive closures of the graphs must be the same due to 
\begin_inset Formula $\mathit{can}(L)\!=\! L\!=\! R\!=\!\mathit{can}(R)$
\end_inset

, the other graph must contain a path 
\begin_inset Formula $t_{1}t_{2}\ldots t_{n}$
\end_inset

 where 
\begin_inset Formula $u\!=\! t_{1}$
\end_inset

, 
\begin_inset Formula $v\!=\! t_{n}$
\end_inset

 and 
\begin_inset Formula $n\!\geq\!3$
\end_inset

; w.l.o.g., we assume that 
\begin_inset Formula $t_{1}t_{2}\ldots t_{n}$
\end_inset

 is a shortest such path.
 Hence, the canonical form (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

) would contain the subexpressions 
\begin_inset Formula $[b_{t_{i}t_{i+1}}](t_{i}\!\rightarrow\! t_{i+1})$
\end_inset

, 
\begin_inset Formula $i=1\ldots n-1$
\end_inset

, and moreover 
\begin_inset Formula $\bigwedge_{i=1}^{n-1}b_{t_{i}t_{i+1}}\neq0$
\end_inset

 for the chosen values of the parameters, and so 
\begin_inset Formula $\bigwedge_{i=1}^{n-1}b_{t_{i}t_{i+1}}\not\equiv0$
\end_inset

.
 But then the iterative process above would have added to the canonical
 form the missing subexpression 
\begin_inset Formula $[b_{t_{1}t_{2}}\wedge b_{t_{2}t_{3}}](t_{1}\!\rightarrow\! t_{3})$
\end_inset

, as the corresponding predicates 
\begin_inset Formula $\not\equiv0$
\end_inset

.
 Hence, for the chosen values of the parameters, there is an arc 
\begin_inset Formula $(t_{1},t_{3})$
\end_inset

, contradicting the assumption that 
\begin_inset Formula $t_{1}t_{2}\ldots t_{n}$
\end_inset

 is a shortest path between
\begin_inset space ~
\end_inset


\begin_inset Formula $u$
\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset Formula $v$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Proof
In both cases there is a contradiction with 
\begin_inset Formula $L=R$
\end_inset

.
\end_layout

\begin_layout Standard
The process of constructing the canonical form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form-tpg"

\end_inset

) of a TPG from the canonical form
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:canonical-form"

\end_inset

) of a PG corresponds to computing the transitive closure of the adjacency
 matrix.
 As the entries of this matrix are predicates rather than Boolean values,
 this has to be done symbolically.
 This is always possible, as each entry of the resulting matrix can be represent
ed as a finite Boolean expression depending on the entries of the original
 matrix only.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fig/cpog_projections_2 _trans.svg
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The PG from Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Specialisations"

\end_inset

 simplified using the Closure axiom, together with its specialisations
\begin_inset CommandInset label
LatexCommand label
name "fig:The-simplified-CG-from"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -6mm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By the same reasoning as in the previous section, we can conclude that the
 following result holds.
\end_layout

\begin_layout Theorem
\begin_inset ERT
status open

\begin_layout Plain Layout

[Soundness, Minimality and Completeness]
\end_layout

\end_inset

 The set of axioms of TPG-algebra is sound, minimal and complete w.r.t.
 TPGs.
\end_layout

\begin_layout Section
Case studies
\end_layout

\begin_layout Standard
In this section we consider several practical case studies from hardware
 synthesis.
 The advantage of (T)PG-algebra is that it allows for a formal and compositional
 approach to system design.
 Moreover, using the rules of (T)PG-algebra one can formally manipulate
 specifications, in particular, algebraically simplify them.
\end_layout

\begin_layout Subsection
Phase encoders
\end_layout

\begin_layout Standard
This section demonstrates the application of PG-algebra to designing the
 
\emph on
multiple rail phase encoding
\emph default
 controllers
\emph on

\begin_inset space ~
\end_inset


\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "2006_cdalessandro_async"

\end_inset

.
 They use several wires for communication, and data is encoded by the order
 of occurrence of transitions in the communication lines.
 Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:phase-encoding"

\end_inset

(a) shows an example of a data packet transmission over a 4-wire phase encoding
 communication channel.
 The order of rising signals on wires indicates that permutation 
\begin_inset Formula $abdc$
\end_inset

 is being transmitted.
 In total it is possible to transmit any of the 
\begin_inset Formula $n!$
\end_inset

 different permutations over an 
\begin_inset Formula $n$
\end_inset

-wire channel in one communication cycle.
 This makes the multiple rail phase encoding protocol very attractive for
 its information efficiency
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2010_mokhov_ieee"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fig/packet.svg
	scale 63

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Phase encoded data
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/matrix_phase_encoder.svg
	scale 41

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Matrix phase encoder
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multiple rail phase encoding
\begin_inset CommandInset label
LatexCommand label
name "fig:phase-encoding"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -6mm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Phase encoding controllers contain an exponential number of behavioural
 scenarios w.r.t.
 the number of wires, and are very difficult for specification and synthesis
 using conventional approaches.
 In this section we apply PG-algebra to specification of an 
\begin_inset Formula $n$
\end_inset

-wire 
\emph on
matrix phase encoder
\emph default
 -- a basic phase encoding controller that generates a permutation of signal
 events given a matrix representing the order of the events in the permutation.
\end_layout

\begin_layout Standard
Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:phase-encoding"

\end_inset

(b) shows the top-level view of the controller's structure.
 Its inputs are 
\begin_inset Formula ${n \choose 2}$
\end_inset

 dual-rail ports that specify the order of signals to be produced at the
 controller's 
\begin_inset Formula $n$
\end_inset

 output wires.
 The inputs of the controller can be viewed as an 
\begin_inset Formula $n\times n$
\end_inset

 Boolean matrix 
\begin_inset Formula $(x_{ij})$
\end_inset

 with diagonal elements being 0.
 The outputs of the controller will be modelled by 
\begin_inset Formula $n$
\end_inset

 actions 
\begin_inset Formula $v_{i}\in\mathcal{A}$
\end_inset

.
 Whenever 
\begin_inset Formula $x_{ij}=1$
\end_inset

, event
\begin_inset space ~
\end_inset


\begin_inset Formula $v_{i}$
\end_inset

 must happen before event
\begin_inset space ~
\end_inset


\begin_inset Formula $v_{j}$
\end_inset

.
 It is guaranteed that 
\begin_inset Formula $x_{ij}$
\end_inset

 and 
\begin_inset Formula $x_{ji}$
\end_inset

 cannot be 1 at the same time, however, they can be simultaneously 0, meaning
 that the relative order of the events is not known yet and the controller
 has to wait until 
\begin_inset Formula $x_{ij}=1$
\end_inset

 or 
\begin_inset Formula $x_{ji}=1$
\end_inset

 is satisfied (other outputs for which the order is already known can be
 generated meanwhile).
 
\end_layout

\begin_layout Standard
The overall specification of the controller is obtained as the overlay 
\begin_inset Formula ${\displaystyle \sum_{1\le i<j\le n}}H_{ij}$
\end_inset

 of fixed-size expressions 
\begin_inset Formula $H_{ij}$
\end_inset

, modelling the behaviour of each pair of outputs.
 In turn, each 
\begin_inset Formula $H_{ij}$
\end_inset

 is an overlay of three possible scenarios:
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $x_{ij}=1$
\end_inset

 (and so 
\begin_inset Formula $x_{ji}=0$
\end_inset

) then there is a causal dependency between 
\begin_inset Formula $v_{i}$
\end_inset

 and 
\begin_inset Formula $v_{j}$
\end_inset

, described using the PG-algebra sequence operator: 
\begin_inset Formula $v_{i}\rightarrow v_{j}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $x_{ji}=1$
\end_inset

 (and so 
\begin_inset Formula $x_{ij}=0$
\end_inset

) then there is a causal dependency between 
\begin_inset Formula $v_{j}$
\end_inset

 and 
\begin_inset Formula $v_{i}$
\end_inset

: 
\begin_inset Formula $v_{j}\rightarrow v_{i}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
If 
\begin_inset Formula $x_{ij}=x_{ji}=0$
\end_inset

 then neither 
\begin_inset Formula $v_{i}$
\end_inset

 nor 
\begin_inset Formula $v_{j}$
\end_inset

 can be produced yet; this is expressed by a circular wait condition between
 
\begin_inset Formula $v_{i}$
\end_inset

 and 
\begin_inset Formula $v_{j}$
\end_inset

: 
\begin_inset Formula $v_{i}\rightarrow v_{j}+v_{j}\rightarrow v_{i}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
There are other ways to describe this scenario, e.g.
 by creating self-loops 
\begin_inset Formula $v_{i}\rightarrow v_{i}+v_{j}\rightarrow v_{j}$
\end_inset

.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
We prefix each of the scenarios with its precondition and overlay the results:
\begin_inset Formula 
\[
\begin{array}{c}
H_{ij}=[x_{ij}\wedge\overline{x_{ji}}](v_{i}\rightarrow v_{j})+[x_{ji}\wedge\overline{x_{ij}}](v_{j}\rightarrow v_{i})+\\
+[\overline{x_{ij}}\wedge\overline{x_{ji}}](v_{i}\rightarrow v_{j}+v_{j}\rightarrow v_{i}).
\end{array}
\]

\end_inset

Using the rules of PG-algebra, we can simplify this expression to
\begin_inset Formula 
\[
[\overline{x_{ji}}](v_{i}\rightarrow v_{j})+[\overline{x_{ij}}](v_{j}\rightarrow v_{i}),
\]

\end_inset

or, using the conditional sequence operator, to
\begin_inset Formula 
\[
[\overline{x_{ij}}\vee\overline{x_{ji}}](v_{i}\overset{\overline{x_{ji}}}{\longrightarrow}v_{j}+v_{j}\overset{\overline{x_{ij}}}{\longrightarrow}v_{i}).
\]

\end_inset


\end_layout

\begin_layout Standard
Now, bearing in mind that condition 
\begin_inset Formula $[\overline{x_{ij}}\vee\overline{x_{ji}}]$
\end_inset

 is assumed to hold in the proper controller environment (
\begin_inset Formula $x_{ij}$
\end_inset

 and 
\begin_inset Formula $x_{ji}$
\end_inset

 cannot be 1 simultaneously), we can replace it with 
\begin_inset Formula $[1]$
\end_inset

 and drop it.
 The resulting expression can be graphically represented as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CGs-related-to"

\end_inset

(a).
 An example of an overall controller specification 
\begin_inset Formula ${\displaystyle \sum_{1\le i<j\le n}}H_{ij}$
\end_inset

 for the case when 
\begin_inset Formula $n=3$
\end_inset

 is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CGs-related-to"

\end_inset

(b).
 The synthesis of this specification to a digital circuit can be performed
 in a way similar to
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2010_mokhov_ieee"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Formula $H_{ij}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/cpog_matrix_sender_ij.svg
	scale 50

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Formula $H_{12}+H_{13}+H_{23}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/cpog_matrix_sender.svg
	scale 50

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PGs related to matrix phase encoder specification
\begin_inset CommandInset label
LatexCommand label
name "fig:CGs-related-to"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -6mm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Processor microcontroller and instruction set design
\end_layout

\begin_layout Standard
This section demonstrates application of TPG-algebra to designing processor
 microcontrollers.
 Specification of such a complex system as a processor has to start at the
 architectural level, which helps to manage the system complexity by structural
 abstraction
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "1994_de_micheli_book"

\end_inset

.
\end_layout

\begin_layout Standard
Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app-fig-Architecture-of-example"

\end_inset

 shows the architecture of an example processor.
 Separate 
\emph on
Program memory
\emph default
 and 
\emph on
Data memory
\emph default
 blocks are accessed via the 
\emph on
Instruction fetch
\emph default
 (IFU) and 
\emph on
Memory access
\emph default
 (MAU) units, respectively.
 The other two operational units are: 
\emph on
Arithmetic logic unit
\emph default
 (ALU) and 
\emph on
Program counter increment unit
\emph default
 (PCIU).
 The units are controlled using request-acknowledgement interfaces (depicted
 as bidirectional arrows) by the
\series bold
\emph on
 
\series default
Central microcontroller
\emph default
, which is our primary design objective.
 
\end_layout

\begin_layout Standard
The processor has four registers: two general purpose registers 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, 
\emph on
Program counter
\emph default
 (PC) storing the address of the current instruction in the program memory,
 and the 
\emph on
Instruction register
\emph default
 (IR) storing the 
\emph on
opcode
\emph default
 (operation code) of the current instruction.
 For the purpose of this paper, the actual width of the registers (the number
 of bits they can store) is not important.
 ALU has access to all the registers via the register bus; MAU has access
 to general purpose registers only; IFU, given the address of the next instructi
on in PC, reads its opcode into IR; and PCIU is responsible for incrementing
 PC (moving to the next instruction).
 The microcontroller has access to the IR and ALU 
\emph on
flags
\emph default
 (information about the current state of ALU which is used in branching
 instructions).
\end_layout

\begin_layout Standard
Now we define the set of instructions of the processor.
 Rather than listing all the instructions, we describe classes of instructions
 with the same 
\emph on
addressing mode
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "mspmanual"

\end_inset

 and the same execution scenario.
 As the scenarios here are partial orders of actions, we use TPG-algebra,
 and the corresponding TPGs are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app-fig-Scenarios-of-8"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
ALU operation Rn to Rn
\series default

\begin_inset space \quad{}
\end_inset

An instruction from this class takes two operands stored in the general
 purpose registers (
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

), performs an operation, and writes the result back into one of the registers
 (so called 
\emph on
register direct addressing mode
\emph default
).
 Examples: 
\begin_inset Formula $\mathit{ADD\ A,\ B}$
\end_inset

 -- addition 
\begin_inset Formula $A:=A+B$
\end_inset

; 
\begin_inset Formula $\mathit{MOV\ B,\ A}$
\end_inset

 -- assignment 
\begin_inset Formula $B:=A$
\end_inset

.
 ALU works concurrently with PCIU and IFU, which is captured by the expression
 
\begin_inset Formula $\mathit{ALU}+\mathit{PCIU\rightarrow\mathit{IFU}}$
\end_inset

; the corresponding PG is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "app-fig-Scenarios-of-8"

\end_inset

(a).
 As soon as both concurrent branches are completed, the processor is ready
 to execute the next instruction.
 Note that it is not important for the microcontroller which particular
 ALU operation is being executed (
\begin_inset Formula $\mathit{ADD}$
\end_inset

, 
\begin_inset Formula $\mathit{MOV}$
\end_inset

, or any other instruction from this class) because the scenario is the
 same from its point of view (it is the responsibility of ALU to detect
 which operation it has to perform according to the current opcode).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fig/processor_architecture.svg
	width 104col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Architecture of an example processor
\begin_inset CommandInset label
LatexCommand label
name "app-fig-Architecture-of-example"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -6mm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ALU op.
 Rn to Rn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_ALU_Rn_Rn.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ALU op.
 #123 to Rn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_ALU_123_Rn.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ALU op.
 Rn to PC
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_ALU_Rn_PC.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ALU op.
 #123 to PC
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_ALU_123_PC.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Memory access
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_MAU.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cond.
 ALU op.
 Rn to Rn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_CALU_Rn_Rn.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cond.
 ALU op.
 #123 to Rn
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_CALU_123_Rn.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Cond.
 ALU op.
 #123 to PC
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename fig/po_CALU_123_PC.svg
	lyxscale 50
	scale 36

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TPG specifications of instruction classes
\begin_inset CommandInset label
LatexCommand label
name "app-fig-Scenarios-of-8"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -6mm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
ALU operation #123 to Rn
\series default

\begin_inset space \quad{}
\end_inset

In this class of instructions one of the operands is a register and the
 other is a constant which is given immediately after the instruction opcode
 (e.g.
 
\begin_inset Formula $\mathit{SUB\ A,\ \#5}$
\end_inset

 -- subtraction 
\begin_inset Formula $A:=A-5$
\end_inset

), so called 
\emph on
immediate addressing mode
\emph default
.
 At first, the constant has to be fetched into IR, modelled as 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}$
\end_inset

.
 Then ALU is executed concurrently with another increment of PC: 
\begin_inset Formula $\mathit{ALU}+\mathit{PCIU'}$
\end_inset

 (we use 
\begin_inset Formula $'$
\end_inset

 to distinguish the different occurrences of actions of the same unit).
 Finally, it is possible to fetch the next instruction into IR: 
\begin_inset Formula $\mathit{IFU'}$
\end_inset

.
 The overall scenario is then 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}\rightarrow(\mathit{ALU}+\mathit{PCIU'})\rightarrow\mathit{IFU'}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
ALU operation Rn to PC
\series default

\begin_inset space \quad{}
\end_inset

This class contains operations for unconditional branching, in which PC
 register is modified.
 Branching can be absolute or relative: 
\begin_inset Formula $\mathit{MOV\ PC,\ A}$
\end_inset

 -- absolute branch to address stored in register 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $PC:=A$
\end_inset

; 
\begin_inset Formula $\mathit{ADD\ PC,\ B}$
\end_inset

 -- relative branch to the address 
\begin_inset Formula $B$
\end_inset

 instructions ahead of the current address, 
\begin_inset Formula $PC:=PC+B$
\end_inset

.
 The scenario is very simple in this case: 
\begin_inset Formula $\mathit{ALU}\rightarrow\mathit{IFU}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
ALU operation #123 to PC
\series default

\begin_inset space \quad{}
\end_inset

Instructions in this class are similar to those above, with the exception
 that the branch address or offset is specified explicitly as a constant.
 The execution scenario is composed of : 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}$
\end_inset

 (to fetch the constant), followed by an ALU operation, and finally by another
 IFU operation, 
\begin_inset Formula $\mathit{IFU'}$
\end_inset

.
 Hence, the overall scenario is 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}\rightarrow\mathit{ALU}\rightarrow\mathit{IFU'}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Memory access
\series default

\begin_inset space \quad{}
\end_inset

There are two instructions in this class: 
\begin_inset Formula $\mathit{MOV\ A,\ [B]}$
\end_inset

 and 
\begin_inset Formula $\mathit{MOV\ [B],\ A}$
\end_inset

.
 They load/save register 
\begin_inset Formula $A$
\end_inset

 from/to memory location with address stored in register 
\begin_inset Formula $B$
\end_inset

.
 Due to the presence of separate program and data memory access blocks,
 this memory access can be performed concurrently with the next instruction
 fetch: 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}+\mathit{MAU}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Conditional instructions
\series default

\begin_inset space \quad{}
\end_inset

These three classes of instructions are similar to their unconditional versions
 above with the difference that they are performed only if the condition
 
\begin_inset Formula $A<B$
\end_inset

 holds.
 The first ALU action compares registers 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, setting the ALU flag 
\begin_inset Formula $lt$
\end_inset

 (less than) according to the result of the comparison.
 This flag is then checked by the microcontroller in order to decide on
 the further scheduling of actions.
 
\end_layout

\begin_layout Standard

\series bold
Rn
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Rn
\series default

\begin_inset space \quad{}
\end_inset

This instruction conditionally performs an ALU operation with the registers
 (if the condition does not hold, the instruction has no effect, except
 changing the ALU flags).
 The operation starts with an ALU operation comparing 
\begin_inset Formula $A$
\end_inset

 with 
\begin_inset Formula $B$
\end_inset

; depending on the result of this comparison, i.e.
 the status of the flag 
\begin_inset Formula $lt$
\end_inset

, the second ALU operation may be performed.
 This is captured by the expression 
\begin_inset Formula $\mathit{ALU}\rightarrow[lt]\mathit{ALU'}$
\end_inset

.
 Concurrently with this, the next instruction is fetched: 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}$
\end_inset

.
 Hence, the overall scenario is 
\begin_inset Formula $\mathit{PCIU}\rightarrow\mathit{IFU}+\mathit{ALU}\rightarrow[lt]\mathit{ALU'}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
#123
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Rn
\series default

\begin_inset space \quad{}
\end_inset

This instruction conditionally performs an ALU operation with a register
 and a constant which is given immediately after the instruction opcode
 (if the condition does not hold, the instruction has no effect, except
 changing the ALU flags).
 We consider the two possible scenarios:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A<B$
\end_inset

 holds: First, ALU compares 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 concurrently with a PC increment; since 
\begin_inset Formula $A<B$
\end_inset

 holds, the ALU sets flag 
\begin_inset Formula $lt$
\end_inset

 and the constant is fetched to the instruction register: 
\begin_inset Formula $(\mathit{ALU}+\mathit{PCIU})\rightarrow\mathit{IFU}$
\end_inset

.
 After that PC has to be incremented again, 
\begin_inset Formula $\mathit{PCIU'}$
\end_inset

, and ALU performs the operation, 
\begin_inset Formula $\mathit{ALU'}$
\end_inset

.
 Finally, the next instruction is fetched (it cannot be fetched concurrently
 with 
\begin_inset Formula $\mathit{ALU'}$
\end_inset

 as ALU is using the constant in IR): 
\begin_inset Formula $(\mathit{ALU'}+\mathit{PCIU'})\rightarrow\mathit{IFU'}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $A<B$
\end_inset

 does not hold: First, ALU compares 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 concurrently with a PC increment; since 
\begin_inset Formula $A<B$
\end_inset

 does not hold, the ALU resets flag 
\begin_inset Formula $lt$
\end_inset

 and the constant that follows the instruction opcode is skipped by incrementing
 the PC: 
\begin_inset Formula $(\mathit{ALU}+\mathit{PCIU})\rightarrow\mathit{PCIU'}$
\end_inset

.
 Finally, the next instruction is fetched: 
\begin_inset Formula $\mathit{IFU'}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Instructions class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Opcode: 
\begin_inset Formula $xyz$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
ALU Rn to Rn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
ALU #123 to Rn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
110
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
ALU Rn to PC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
101
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
ALU #123 to PC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
010
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Memory access
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C/ALU Rn to Rn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
001
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C/ALU #123 to Rn
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
C/ALU #123 to PC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
011
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{-5em}[0em]{
\end_layout

\end_inset


\begin_inset Graphics
	filename fig/CPOG_L_3.svg
	scale 50

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset space \hspace*{\fill}
\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Optimal 3-bit instruction opcodes and the corresponding TPG specification
 of the microcontroller
\begin_inset CommandInset label
LatexCommand label
name "fig:opcodes-and-CG"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace -6mm
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hence, the overall scenario is the overlay of the two subscenarios above
 prefixed with appropriate conditions (here we denote the predicate 
\begin_inset Formula $A<B$
\end_inset

 by 
\begin_inset Formula $lt$
\end_inset

): 
\begin_inset Formula 
\[
\begin{array}{c}
[lt]((\mathit{ALU}+\mathit{PCIU})\!\rightarrow\!\mathit{IFU}\!\rightarrow\!(\mathit{ALU'}+\mathit{PCIU'})\!\rightarrow\!\mathit{IFU'})+\\
+[\overline{lt}]((\mathit{ALU}+\mathit{PCIU})\!\rightarrow\!\mathit{PCIU'}\!\rightarrow\!\mathit{IFU'}).
\end{array}
\]

\end_inset

This expression can be simplified using the rules of TPG-algebra:
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This case illustrates the advantage of using the new hierarchical approach
 that allows to specify the system as a composition of scenarios and formally
 manipulate them in an algebraic fashion.
 In the previous paper
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2011_mokhov_iet"

\end_inset

 the CPOG for this class of instruction was designed monolithically, and
 because of this the arc between 
\begin_inset Formula $\mathit{ALU'}$
\end_inset

 and 
\begin_inset Formula $\mathit{IFU'}$
\end_inset

 was missed.
 Adding this arc not only fixes the dangerous race between these two blocks,
 but also leads to a smaller microcontroller due to the additional similarity
 between TPGs for this class of instructions and for the one described below.
\end_layout

\end_inset


\begin_inset Formula 
\[
(\mathit{ALU}+\mathit{PCIU})\!\rightarrow\![lt]\mathit{IFU}\!\rightarrow\!(\mathit{PCIU'}+[lt]\mathit{ALU'})\!\rightarrow\!\mathit{IFU'}.
\]

\end_inset


\end_layout

\begin_layout Standard

\series bold
#123
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

PC
\series default

\begin_inset space \quad{}
\end_inset

This instruction performs a conditional branching in which the branch address
 or offset is specified explicitly as a constant.
 We consider the two possible scenarios:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A<B$
\end_inset

 holds: First, ALU compares 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 concurrently with a PC increment; since 
\begin_inset Formula $A<B$
\end_inset

 holds, the ALU sets flag 
\begin_inset Formula $lt$
\end_inset

 and the constant is fetched to the instruction register: 
\begin_inset Formula $(\mathit{ALU}+\mathit{PCIU})\rightarrow\mathit{IFU}$
\end_inset

.
 After that ALU performs the branching operation by modifying PC, 
\begin_inset Formula $\mathit{ALU'}$
\end_inset

.
 After PC is changed, the next instruction is fetched, 
\begin_inset Formula $\mathit{IFU'}$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $A<B$
\end_inset

 does not hold: the scenario is exactly the same as in the 
\series bold
#123
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

Rn 
\series default
case when 
\begin_inset Formula $A<B$
\end_inset

 does not hold.
\end_layout

\begin_layout Standard
Hence, the overall scenario is the overlay of the two subscenarios above
 prefixed with appropriate conditions (here we denote the predicate 
\begin_inset Formula $A<B$
\end_inset

 by 
\begin_inset Formula $lt$
\end_inset

): 
\begin_inset Formula 
\[
\begin{array}{c}
[lt]((\mathit{ALU}+\mathit{PCIU})\!\rightarrow\!\mathit{IFU}\!\rightarrow\!\mathit{ALU'}\!\rightarrow\!\mathit{IFU'})+\\
+[\overline{lt}]((\mathit{ALU}+\mathit{PCIU})\!\rightarrow\!\mathit{PCIU'}\!\rightarrow\!\mathit{IFU'}).
\end{array}
\]

\end_inset

This expression can be simplified using the rules of TPG-algebra:
\begin_inset Formula 
\[
(\mathit{ALU}+\mathit{PCIU})\!\rightarrow\!([\overline{lt}]\mathit{PCIU'}+[lt](\mathit{IFU}\!\rightarrow\!\mathit{ALU'}))\!\rightarrow\!\mathit{IFU'}.
\]

\end_inset


\end_layout

\begin_layout Standard
The overall specification of the microcontroller can now be obtained by
 prefixing the scenarios with appropriate conditions and overlaying them.
 These conditions can be naturally derived from the instruction opcodes.
 The opcodes can be either imposed externally or chosen with the view to
 optimise the microcontroller.
 In the latter case, TPG-algebra and TPGs allow for a formal statement of
 this optimisation problem and aid in its solving; in particular, the sizes
 of the TPG-algebra expression or TPG are useful measures of microcontroller
 complexity (there is a compositional translation from a TPG-algebra expression
 into a linear-size circuit).
 In this paper we do not go into details how to select the optimal encoding,
 but see
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2011_mokhov_iet"

\end_inset

.
 We just note that it is natural to use three bits for opcodes as there
 are eight classes of instructions, and give an example of optimal 3-bit
 encoding in the table in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:opcodes-and-CG"

\end_inset

; the TPG specification of the corresponding microcontroller is shown in
 the right part of this figure (the TPG-algebra expression is not shown
 because of its size).
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
We introduced a new formalism called Parameterised Graphs and the corresponding
 algebra.
 The formalism allows to manage a large number of system configurations
 and execution modes, exploit similarities between them to simplify the
 specification, and to work with groups of configurations and modes rather
 than with individual ones.
 The modes and groups of modes can be managed in a compositional way, and
 the specifications can be manipulated (transformed and/or optimised) algebraica
lly in a fully formal and natural way.
\end_layout

\begin_layout Standard
We develop two variants of the algebra of parameterised graphs, corresponding
 to the two natural graph equivalences: graph isomorphism and isomorphism
 of transitive closures.
 Both cases are specified axiomatically, and the soundness, minimality and
 completeness of the resulting sets of axioms are formally proved.
 Moreover, the canonical forms of algebraic terms are developed in each
 case.
\end_layout

\begin_layout Standard
The usefulness of the developed formalism has been demonstrated on two case
 studies, a phase encoding controller and a processor microcontroller.
 Both have a large number of execution scenarios, and the developed formalism
 allows to capture them algebraically, by composing individual scenarios
 and groups of scenarios.
 The possibility of algebraical manipulation was essential to obtain the
 optimised final specification in each case.
\end_layout

\begin_layout Standard
The developed formalism is also convenient for implementation in a tool,
 as manipulating algebraic terms is much easier than general graph manipulation;
 in particular, the theory of term rewriting can be naturally applied to
 derive the canonical forms.
\end_layout

\begin_layout Standard
In future work we plan to automate the algebraic manipulation of PGs, and
 implement automatic synthesis of PGs into digital circuits.
 For the latter, much of the code developed for the precursor formalism
 of Conditional Partial Order Graphs (CPOGs) can be re-used.
 One of the important problems that needs to be automated is that of simplificat
ion of (T)PG expressions, in the sense of deriving an equivalent expression
 with the minimum possible number of operators.
 Our preliminary research suggests that this problem is strongly related
 to modular decomposition of graphs
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "2005_McConnell_modular"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Acknowledgements
\series default

\begin_inset space \quad{}
\end_inset

The authors would like to thank Ashur Rafiev for useful discussions.
 This research was supported by the 
\noun on
Epsrc
\noun default
 grants EP/G037809/1 (
\noun on
Verdad
\noun default
) and EP/J008133/1 (TrAmS-2).
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "publications,danil"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
